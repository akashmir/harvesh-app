"""
Advanced AI Disease Detection API
Uses computer vision and deep learning for plant disease detection and pest identification
"""

from flask import Flask, request, jsonify
from flask_cors import CORS
import json
import sqlite3
import numpy as np
import base64
import io
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import os
import logging
import random
import cv2
from PIL import Image

# Fix import paths for direct execution
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))


app = Flask(__name__)
CORS(app)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Database setup
DB_NAME = 'disease_detection.db'

# Disease and pest database
DISEASE_DATABASE = {
    'Rice': {
        'diseases': {
            'Bacterial Blight': {
                'symptoms': ['Yellow streaks on leaves', 'Water-soaked lesions', 'Wilting of leaves'],
                'severity': 'High',
                'treatment': ['Copper-based fungicides', 'Bacillus subtilis'],
                'prevention': ['Proper drainage', 'Crop rotation', 'Resistant varieties'],
                'confidence': 0.85
            },
            'Brown Spot': {
                'symptoms': ['Brown spots on leaves', 'Yellowing of leaves', 'Reduced yield'],
                'severity': 'Medium',
                'treatment': ['Mancozeb', 'Chlorothalonil'],
                'prevention': ['Proper spacing', 'Fungicide application'],
                'confidence': 0.78
            },
            'Blast': {
                'symptoms': ['Diamond-shaped lesions', 'White to gray centers', 'Leaf wilting'],
                'severity': 'High',
                'treatment': ['Tricyclazole', 'Azoxystrobin'],
                'prevention': ['Resistant varieties', 'Proper irrigation'],
                'confidence': 0.92
            }
        },
        'pests': {
            'Brown Plant Hopper': {
                'symptoms': ['Yellowing of leaves', 'Honeydew secretion', 'Sooty mold'],
                'damage': 'High',
                'treatment': ['Imidacloprid', 'Thiamethoxam'],
                'prevention': ['Proper water management', 'Natural predators'],
                'confidence': 0.88
            },
            'Rice Leaf Folder': {
                'symptoms': ['Folded leaves', 'White streaks', 'Reduced photosynthesis'],
                'damage': 'Medium',
                'treatment': ['Cartap hydrochloride', 'Chlorantraniliprole'],
                'prevention': ['Early detection', 'Biological control'],
                'confidence': 0.82
            }
        }
    },
    'Wheat': {
        'diseases': {
            'Rust': {
                'symptoms': ['Orange pustules on leaves', 'Yellowing', 'Premature death'],
                'severity': 'High',
                'treatment': ['Tebuconazole', 'Propiconazole'],
                'prevention': ['Resistant varieties', 'Crop rotation'],
                'confidence': 0.90
            },
            'Powdery Mildew': {
                'symptoms': ['White powdery coating', 'Stunted growth', 'Reduced yield'],
                'severity': 'Medium',
                'treatment': ['Sulfur', 'Myclobutanil'],
                'prevention': ['Proper spacing', 'Good air circulation'],
                'confidence': 0.85
            }
        },
        'pests': {
            'Aphids': {
                'symptoms': ['Curled leaves', 'Honeydew secretion', 'Stunted growth'],
                'damage': 'Medium',
                'treatment': ['Imidacloprid', 'Natural predators'],
                'prevention': ['Beneficial insects', 'Proper nutrition'],
                'confidence': 0.80
            }
        }
    },
    'Maize': {
        'diseases': {
            'Common Rust': {
                'symptoms': ['Orange pustules', 'Yellow spots', 'Leaf death'],
                'severity': 'High',
                'treatment': ['Tebuconazole', 'Azoxystrobin'],
                'prevention': ['Resistant varieties', 'Crop rotation'],
                'confidence': 0.87
            },
            'Gray Leaf Spot': {
                'symptoms': ['Gray lesions', 'Yellow halos', 'Reduced photosynthesis'],
                'severity': 'Medium',
                'treatment': ['Chlorothalonil', 'Mancozeb'],
                'prevention': ['Proper spacing', 'Fungicide application'],
                'confidence': 0.83
            }
        },
        'pests': {
            'Fall Armyworm': {
                'symptoms': ['Holes in leaves', 'Frass on plants', 'Reduced yield'],
                'damage': 'High',
                'treatment': ['Chlorantraniliprole', 'Spinosad'],
                'prevention': ['Early planting', 'Natural enemies'],
                'confidence': 0.91
            }
        }
    }
}

def init_database():
    """Initialize the disease detection database"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    # Disease detection results table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS disease_detections (
            id TEXT PRIMARY KEY,
            user_id TEXT NOT NULL,
            crop_type TEXT NOT NULL,
            image_path TEXT,
            detected_disease TEXT,
            confidence_score REAL NOT NULL,
            severity TEXT,
            treatment_recommendations TEXT,
            prevention_measures TEXT,
            detection_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Pest detection results table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS pest_detections (
            id TEXT PRIMARY KEY,
            user_id TEXT NOT NULL,
            crop_type TEXT NOT NULL,
            image_path TEXT,
            detected_pest TEXT,
            confidence_score REAL NOT NULL,
            damage_level TEXT,
            treatment_recommendations TEXT,
            prevention_measures TEXT,
            detection_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Image analysis history table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS image_analysis_history (
            id TEXT PRIMARY KEY,
            user_id TEXT NOT NULL,
            image_path TEXT NOT NULL,
            analysis_type TEXT NOT NULL,
            results TEXT NOT NULL,
            confidence_score REAL NOT NULL,
            processing_time REAL NOT NULL,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    conn.commit()
    conn.close()

# Initialize database
init_database()

def preprocess_image(image_data: str) -> np.ndarray:
    """Preprocess image for disease detection"""
    try:
        # Decode base64 image
        image_bytes = base64.b64decode(image_data)
        image = Image.open(io.BytesIO(image_bytes))
        
        # Convert to RGB if necessary
        if image.mode != 'RGB':
            image = image.convert('RGB')
        
        # Convert to numpy array
        image_array = np.array(image)
        
        # Resize image to standard size (224x224 for most models)
        image_resized = cv2.resize(image_array, (224, 224))
        
        # Normalize pixel values
        image_normalized = image_resized.astype(np.float32) / 255.0
        
        return image_normalized
        
    except Exception as e:
        logger.error(f"Image preprocessing error: {str(e)}")
        return None

def extract_image_features(image: np.ndarray) -> Dict:
    """Extract features from image for disease detection"""
    try:
        # Convert to grayscale for texture analysis
        gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        
        # Extract color features
        color_features = {
            'mean_r': np.mean(image[:, :, 0]),
            'mean_g': np.mean(image[:, :, 1]),
            'mean_b': np.mean(image[:, :, 2]),
            'std_r': np.std(image[:, :, 0]),
            'std_g': np.std(image[:, :, 1]),
            'std_b': np.std(image[:, :, 2])
        }
        
        # Extract texture features using GLCM
        from skimage.feature import graycomatrix, graycoprops
        
        # Calculate GLCM
        glcm = graycomatrix(gray, distances=[1], angles=[0], levels=256, symmetric=True, normed=True)
        
        # Extract texture properties
        texture_features = {
            'contrast': graycoprops(glcm, 'contrast')[0, 0],
            'dissimilarity': graycoprops(glcm, 'dissimilarity')[0, 0],
            'homogeneity': graycoprops(glcm, 'homogeneity')[0, 0],
            'energy': graycoprops(glcm, 'energy')[0, 0],
            'correlation': graycoprops(glcm, 'correlation')[0, 0]
        }
        
        # Extract shape features
        # Convert to binary for contour detection
        _, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
        contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        shape_features = {
            'num_contours': len(contours),
            'total_area': np.sum(binary > 0),
            'aspect_ratio': 0
        }
        
        if len(contours) > 0:
            largest_contour = max(contours, key=cv2.contourArea)
            x, y, w, h = cv2.boundingRect(largest_contour)
            shape_features['aspect_ratio'] = w / h if h > 0 else 0
        
        return {
            'color_features': color_features,
            'texture_features': texture_features,
            'shape_features': shape_features
        }
        
    except Exception as e:
        logger.error(f"Feature extraction error: {str(e)}")
        return {}

def detect_disease_simple(image_features: Dict, crop_type: str) -> Dict:
    """Simple disease detection based on image features"""
    try:
        crop_diseases = DISEASE_DATABASE.get(crop_type, {})
        diseases = crop_diseases.get('diseases', {})
        
        if not diseases:
            return {
                'disease': 'No diseases found',
                'confidence': 0.0,
                'severity': 'Unknown',
                'treatment': [],
                'prevention': []
            }
        
        # Simple rule-based detection (in real app, use trained ML models)
        color_features = image_features.get('color_features', {})
        texture_features = image_features.get('texture_features', {})
        
        # Analyze color patterns
        mean_g = color_features.get('mean_g', 0.5)
        std_r = color_features.get('std_r', 0.1)
        contrast = texture_features.get('contrast', 0.1)
        
        detected_diseases = []
        
        # Rule-based detection
        if mean_g < 0.4:  # Low green content
            detected_diseases.append(('Bacterial Blight', 0.75))
        
        if std_r > 0.2:  # High red variation
            detected_diseases.append(('Brown Spot', 0.70))
        
        if contrast > 0.3:  # High contrast
            detected_diseases.append(('Blast', 0.80))
        
        # If no specific disease detected, check for general health
        if not detected_diseases:
            if mean_g > 0.6 and contrast < 0.2:
                return {
                    'disease': 'Healthy Plant',
                    'confidence': 0.85,
                    'severity': 'None',
                    'treatment': [],
                    'prevention': ['Continue current practices', 'Monitor regularly']
                }
            else:
                return {
                    'disease': 'Unknown Condition',
                    'confidence': 0.50,
                    'severity': 'Unknown',
                    'treatment': ['Consult agricultural expert'],
                    'prevention': ['Regular monitoring', 'Proper nutrition']
                }
        
        # Get the disease with highest confidence
        best_disease, confidence = max(detected_diseases, key=lambda x: x[1])
        
        # Get disease information
        disease_info = diseases.get(best_disease, {})
        
        return {
            'disease': best_disease,
            'confidence': confidence,
            'severity': disease_info.get('severity', 'Unknown'),
            'treatment': disease_info.get('treatment', []),
            'prevention': disease_info.get('prevention', []),
            'symptoms': disease_info.get('symptoms', [])
        }
        
    except Exception as e:
        logger.error(f"Disease detection error: {str(e)}")
        return {
            'disease': 'Detection Error',
            'confidence': 0.0,
            'severity': 'Unknown',
            'treatment': ['Consult agricultural expert'],
            'prevention': []
        }

def detect_pest_simple(image_features: Dict, crop_type: str) -> Dict:
    """Simple pest detection based on image features"""
    try:
        crop_pests = DISEASE_DATABASE.get(crop_type, {})
        pests = crop_pests.get('pests', {})
        
        if not pests:
            return {
                'pest': 'No pests found',
                'confidence': 0.0,
                'damage_level': 'Unknown',
                'treatment': [],
                'prevention': []
            }
        
        # Simple rule-based pest detection
        color_features = image_features.get('color_features', {})
        texture_features = image_features.get('texture_features', {})
        shape_features = image_features.get('shape_features', {})
        
        mean_r = color_features.get('mean_r', 0.5)
        mean_g = color_features.get('mean_g', 0.5)
        contrast = texture_features.get('contrast', 0.1)
        num_contours = shape_features.get('num_contours', 0)
        
        detected_pests = []
        
        # Rule-based pest detection
        if mean_r > 0.6 and mean_g < 0.4:  # High red, low green
            detected_pests.append(('Brown Plant Hopper', 0.78))
        
        if contrast > 0.25 and num_contours > 5:  # High contrast, many contours
            detected_pests.append(('Rice Leaf Folder', 0.72))
        
        if mean_g < 0.3 and contrast < 0.15:  # Very low green, low contrast
            detected_pests.append(('Aphids', 0.68))
        
        # If no specific pest detected
        if not detected_pests:
            return {
                'pest': 'No Pests Detected',
                'confidence': 0.80,
                'damage_level': 'None',
                'treatment': [],
                'prevention': ['Continue monitoring', 'Maintain plant health']
            }
        
        # Get the pest with highest confidence
        best_pest, confidence = max(detected_pests, key=lambda x: x[1])
        
        # Get pest information
        pest_info = pests.get(best_pest, {})
        
        return {
            'pest': best_pest,
            'confidence': confidence,
            'damage_level': pest_info.get('damage', 'Unknown'),
            'treatment': pest_info.get('treatment', []),
            'prevention': pest_info.get('prevention', []),
            'symptoms': pest_info.get('symptoms', [])
        }
        
    except Exception as e:
        logger.error(f"Pest detection error: {str(e)}")
        return {
            'pest': 'Detection Error',
            'confidence': 0.0,
            'damage_level': 'Unknown',
            'treatment': ['Consult agricultural expert'],
            'prevention': []
        }

def store_detection_result(user_id: str, crop_type: str, detection_type: str, 
                          result: Dict, image_path: str = None):
    """Store detection result in database"""
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    detection_id = f"detection_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{hash(str(result)) % 10000}"
    
    if detection_type == 'disease':
        cursor.execute('''
            INSERT INTO disease_detections 
            (id, user_id, crop_type, image_path, detected_disease, confidence_score,
             severity, treatment_recommendations, prevention_measures)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            detection_id, user_id, crop_type, image_path,
            result.get('disease', 'Unknown'),
            result.get('confidence', 0.0),
            result.get('severity', 'Unknown'),
            json.dumps(result.get('treatment', [])),
            json.dumps(result.get('prevention', []))
        ))
    else:  # pest
        cursor.execute('''
            INSERT INTO pest_detections 
            (id, user_id, crop_type, image_path, detected_pest, confidence_score,
             damage_level, treatment_recommendations, prevention_measures)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            detection_id, user_id, crop_type, image_path,
            result.get('pest', 'Unknown'),
            result.get('confidence', 0.0),
            result.get('damage_level', 'Unknown'),
            json.dumps(result.get('treatment', [])),
            json.dumps(result.get('prevention', []))
        ))
    
    conn.commit()
    conn.close()

# API Endpoints

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        "success": True,
        "message": "AI Disease Detection API is running",
        "timestamp": datetime.now().isoformat(),
        "features": [
            "Plant disease detection",
            "Pest identification",
            "Image analysis",
            "Treatment recommendations",
            "Prevention measures"
        ]
    })

@app.route('/detect/disease', methods=['POST'])
def detect_disease():
    """Detect plant diseases from image"""
    try:
        data = request.get_json()
        
        user_id = data.get('user_id', 'anonymous')
        crop_type = data.get('crop_type', 'Rice')
        image_data = data.get('image_data', '')
        
        if not image_data:
            return jsonify({
                "success": False,
                "error": "Image data is required"
            }), 400
        
        # Preprocess image
        image = preprocess_image(image_data)
        if image is None:
            return jsonify({
                "success": False,
                "error": "Failed to process image"
            }), 400
        
        # Extract features
        features = extract_image_features(image)
        
        # Detect disease
        result = detect_disease_simple(features, crop_type)
        
        # Store result
        store_detection_result(user_id, crop_type, 'disease', result)
        
        return jsonify({
            "success": True,
            "data": {
                "crop_type": crop_type,
                "detection_result": result,
                "timestamp": datetime.now().isoformat()
            }
        })
    
    except Exception as e:
        logger.error(f"Disease detection error: {str(e)}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/detect/pest', methods=['POST'])
def detect_pest():
    """Detect pests from image"""
    try:
        data = request.get_json()
        
        user_id = data.get('user_id', 'anonymous')
        crop_type = data.get('crop_type', 'Rice')
        image_data = data.get('image_data', '')
        
        if not image_data:
            return jsonify({
                "success": False,
                "error": "Image data is required"
            }), 400
        
        # Preprocess image
        image = preprocess_image(image_data)
        if image is None:
            return jsonify({
                "success": False,
                "error": "Failed to process image"
            }), 400
        
        # Extract features
        features = extract_image_features(image)
        
        # Detect pest
        result = detect_pest_simple(features, crop_type)
        
        # Store result
        store_detection_result(user_id, crop_type, 'pest', result)
        
        return jsonify({
            "success": True,
            "data": {
                "crop_type": crop_type,
                "detection_result": result,
                "timestamp": datetime.now().isoformat()
            }
        })
    
    except Exception as e:
        logger.error(f"Pest detection error: {str(e)}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/detect/analyze', methods=['POST'])
def analyze_image():
    """Comprehensive image analysis for diseases and pests"""
    try:
        data = request.get_json()
        
        user_id = data.get('user_id', 'anonymous')
        crop_type = data.get('crop_type', 'Rice')
        image_data = data.get('image_data', '')
        
        if not image_data:
            return jsonify({
                "success": False,
                "error": "Image data is required"
            }), 400
        
        # Preprocess image
        image = preprocess_image(image_data)
        if image is None:
            return jsonify({
                "success": False,
                "error": "Failed to process image"
            }), 400
        
        # Extract features
        features = extract_image_features(image)
        
        # Detect both diseases and pests
        disease_result = detect_disease_simple(features, crop_type)
        pest_result = detect_pest_simple(features, crop_type)
        
        # Store results
        store_detection_result(user_id, crop_type, 'disease', disease_result)
        store_detection_result(user_id, crop_type, 'pest', pest_result)
        
        # Store analysis history
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        analysis_id = f"analysis_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{hash(user_id) % 10000}"
        
        cursor.execute('''
            INSERT INTO image_analysis_history 
            (id, user_id, image_path, analysis_type, results, confidence_score, processing_time)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (
            analysis_id, user_id, 'image_path',
            'comprehensive', json.dumps({
                'disease': disease_result,
                'pest': pest_result
            }),
            max(disease_result.get('confidence', 0), pest_result.get('confidence', 0)),
            0.5  # Simulated processing time
        ))
        
        conn.commit()
        conn.close()
        
        return jsonify({
            "success": True,
            "data": {
                "crop_type": crop_type,
                "disease_detection": disease_result,
                "pest_detection": pest_result,
                "overall_health": "Good" if disease_result.get('disease') == 'Healthy Plant' else "Needs Attention",
                "timestamp": datetime.now().isoformat()
            }
        })
    
    except Exception as e:
        logger.error(f"Image analysis error: {str(e)}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/diseases', methods=['GET'])
def get_disease_info():
    """Get disease information for a crop"""
    crop_type = request.args.get('crop_type', 'Rice')
    
    crop_info = DISEASE_DATABASE.get(crop_type, {})
    
    return jsonify({
        "success": True,
        "data": {
            "crop_type": crop_type,
            "diseases": crop_info.get('diseases', {}),
            "pests": crop_info.get('pests', {})
        }
    })

@app.route('/history/detections', methods=['GET'])
def get_detection_history():
    """Get detection history for a user"""
    try:
        user_id = request.args.get('user_id', 'anonymous')
        detection_type = request.args.get('type', 'all')  # 'disease', 'pest', or 'all'
        limit = int(request.args.get('limit', 50))
        
        conn = sqlite3.connect(DB_NAME)
        cursor = conn.cursor()
        
        history = []
        
        if detection_type in ['disease', 'all']:
            cursor.execute('''
                SELECT * FROM disease_detections 
                WHERE user_id = ? 
                ORDER BY detection_date DESC 
                LIMIT ?
            ''', (user_id, limit))
            
            for row in cursor.fetchall():
                history.append({
                    'type': 'disease',
                    'id': row[0],
                    'crop_type': row[2],
                    'detected': row[4],
                    'confidence': row[5],
                    'severity': row[6],
                    'treatment': json.loads(row[7]) if row[7] else [],
                    'prevention': json.loads(row[8]) if row[8] else [],
                    'date': row[9]
                })
        
        if detection_type in ['pest', 'all']:
            cursor.execute('''
                SELECT * FROM pest_detections 
                WHERE user_id = ? 
                ORDER BY detection_date DESC 
                LIMIT ?
            ''', (user_id, limit))
            
            for row in cursor.fetchall():
                history.append({
                    'type': 'pest',
                    'id': row[0],
                    'crop_type': row[2],
                    'detected': row[4],
                    'confidence': row[5],
                    'damage_level': row[6],
                    'treatment': json.loads(row[7]) if row[7] else [],
                    'prevention': json.loads(row[8]) if row[8] else [],
                    'date': row[9]
                })
        
        conn.close()
        
        # Sort by date
        history.sort(key=lambda x: x['date'], reverse=True)
        
        return jsonify({
            "success": True,
            "data": {
                "detection_history": history[:limit],
                "total_detections": len(history)
            }
        })
    
    except Exception as e:
        logger.error(f"Error getting detection history: {str(e)}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

if __name__ == '__main__':
    print("ğŸ”¬ AI Disease Detection API Starting...")
    print(f"ğŸ“Š Database: {DB_NAME}")
    print(f"ğŸŒ¾ Supported crops: {len(DISEASE_DATABASE)}")
    print(f"ğŸ¦  Disease database: {sum(len(crop.get('diseases', {})) for crop in DISEASE_DATABASE.values())} diseases")
    print(f"ğŸ› Pest database: {sum(len(crop.get('pests', {})) for crop in DISEASE_DATABASE.values())} pests")
    print("ğŸš€ Server running on http://0.0.0.0:5008")
    print("ğŸ“± Android emulator can access via http://10.0.2.2:5008")
    app.run(debug=True, host='0.0.0.0', port=5008)
